// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: osmosis/incentives/query.proto

package incentives

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueryClient interface {
	// ModuleToDistributeCoins returns coins that are going to be distributed
	ModuleToDistributeCoins(ctx context.Context, in *ModuleToDistributeCoinsRequest, opts ...grpc.CallOption) (*ModuleToDistributeCoinsResponse, error)
	// GaugeByID returns gauges by their respective ID
	GaugeByID(ctx context.Context, in *GaugeByIDRequest, opts ...grpc.CallOption) (*GaugeByIDResponse, error)
	// Gauges returns both upcoming and active gauges
	Gauges(ctx context.Context, in *GaugesRequest, opts ...grpc.CallOption) (*GaugesResponse, error)
	// ActiveGauges returns active gauges
	ActiveGauges(ctx context.Context, in *ActiveGaugesRequest, opts ...grpc.CallOption) (*ActiveGaugesResponse, error)
	// ActiveGaugesPerDenom returns active gauges by denom
	ActiveGaugesPerDenom(ctx context.Context, in *ActiveGaugesPerDenomRequest, opts ...grpc.CallOption) (*ActiveGaugesPerDenomResponse, error)
	// Returns scheduled gauges that have not yet occured
	UpcomingGauges(ctx context.Context, in *UpcomingGaugesRequest, opts ...grpc.CallOption) (*UpcomingGaugesResponse, error)
	// UpcomingGaugesPerDenom returns scheduled gauges that have not yet occured
	// by denom
	UpcomingGaugesPerDenom(ctx context.Context, in *UpcomingGaugesPerDenomRequest, opts ...grpc.CallOption) (*UpcomingGaugesPerDenomResponse, error)
	// RewardsEst returns an estimate of the rewards from now until a specified
	// time in the future The querier either provides an address or a set of locks
	// for which they want to find the associated rewards
	RewardsEst(ctx context.Context, in *RewardsEstRequest, opts ...grpc.CallOption) (*RewardsEstResponse, error)
	// LockableDurations returns lockable durations that are valid to distribute
	// incentives for
	LockableDurations(ctx context.Context, in *QueryLockableDurationsRequest, opts ...grpc.CallOption) (*QueryLockableDurationsResponse, error)
}

type queryClient struct {
	cc grpc.ClientConnInterface
}

func NewQueryClient(cc grpc.ClientConnInterface) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) ModuleToDistributeCoins(ctx context.Context, in *ModuleToDistributeCoinsRequest, opts ...grpc.CallOption) (*ModuleToDistributeCoinsResponse, error) {
	out := new(ModuleToDistributeCoinsResponse)
	err := c.cc.Invoke(ctx, "/osmosis.incentives.Query/ModuleToDistributeCoins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GaugeByID(ctx context.Context, in *GaugeByIDRequest, opts ...grpc.CallOption) (*GaugeByIDResponse, error) {
	out := new(GaugeByIDResponse)
	err := c.cc.Invoke(ctx, "/osmosis.incentives.Query/GaugeByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Gauges(ctx context.Context, in *GaugesRequest, opts ...grpc.CallOption) (*GaugesResponse, error) {
	out := new(GaugesResponse)
	err := c.cc.Invoke(ctx, "/osmosis.incentives.Query/Gauges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ActiveGauges(ctx context.Context, in *ActiveGaugesRequest, opts ...grpc.CallOption) (*ActiveGaugesResponse, error) {
	out := new(ActiveGaugesResponse)
	err := c.cc.Invoke(ctx, "/osmosis.incentives.Query/ActiveGauges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ActiveGaugesPerDenom(ctx context.Context, in *ActiveGaugesPerDenomRequest, opts ...grpc.CallOption) (*ActiveGaugesPerDenomResponse, error) {
	out := new(ActiveGaugesPerDenomResponse)
	err := c.cc.Invoke(ctx, "/osmosis.incentives.Query/ActiveGaugesPerDenom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) UpcomingGauges(ctx context.Context, in *UpcomingGaugesRequest, opts ...grpc.CallOption) (*UpcomingGaugesResponse, error) {
	out := new(UpcomingGaugesResponse)
	err := c.cc.Invoke(ctx, "/osmosis.incentives.Query/UpcomingGauges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) UpcomingGaugesPerDenom(ctx context.Context, in *UpcomingGaugesPerDenomRequest, opts ...grpc.CallOption) (*UpcomingGaugesPerDenomResponse, error) {
	out := new(UpcomingGaugesPerDenomResponse)
	err := c.cc.Invoke(ctx, "/osmosis.incentives.Query/UpcomingGaugesPerDenom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) RewardsEst(ctx context.Context, in *RewardsEstRequest, opts ...grpc.CallOption) (*RewardsEstResponse, error) {
	out := new(RewardsEstResponse)
	err := c.cc.Invoke(ctx, "/osmosis.incentives.Query/RewardsEst", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) LockableDurations(ctx context.Context, in *QueryLockableDurationsRequest, opts ...grpc.CallOption) (*QueryLockableDurationsResponse, error) {
	out := new(QueryLockableDurationsResponse)
	err := c.cc.Invoke(ctx, "/osmosis.incentives.Query/LockableDurations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
// All implementations must embed UnimplementedQueryServer
// for forward compatibility
type QueryServer interface {
	// ModuleToDistributeCoins returns coins that are going to be distributed
	ModuleToDistributeCoins(context.Context, *ModuleToDistributeCoinsRequest) (*ModuleToDistributeCoinsResponse, error)
	// GaugeByID returns gauges by their respective ID
	GaugeByID(context.Context, *GaugeByIDRequest) (*GaugeByIDResponse, error)
	// Gauges returns both upcoming and active gauges
	Gauges(context.Context, *GaugesRequest) (*GaugesResponse, error)
	// ActiveGauges returns active gauges
	ActiveGauges(context.Context, *ActiveGaugesRequest) (*ActiveGaugesResponse, error)
	// ActiveGaugesPerDenom returns active gauges by denom
	ActiveGaugesPerDenom(context.Context, *ActiveGaugesPerDenomRequest) (*ActiveGaugesPerDenomResponse, error)
	// Returns scheduled gauges that have not yet occured
	UpcomingGauges(context.Context, *UpcomingGaugesRequest) (*UpcomingGaugesResponse, error)
	// UpcomingGaugesPerDenom returns scheduled gauges that have not yet occured
	// by denom
	UpcomingGaugesPerDenom(context.Context, *UpcomingGaugesPerDenomRequest) (*UpcomingGaugesPerDenomResponse, error)
	// RewardsEst returns an estimate of the rewards from now until a specified
	// time in the future The querier either provides an address or a set of locks
	// for which they want to find the associated rewards
	RewardsEst(context.Context, *RewardsEstRequest) (*RewardsEstResponse, error)
	// LockableDurations returns lockable durations that are valid to distribute
	// incentives for
	LockableDurations(context.Context, *QueryLockableDurationsRequest) (*QueryLockableDurationsResponse, error)
	mustEmbedUnimplementedQueryServer()
}

// UnimplementedQueryServer must be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (UnimplementedQueryServer) ModuleToDistributeCoins(context.Context, *ModuleToDistributeCoinsRequest) (*ModuleToDistributeCoinsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleToDistributeCoins not implemented")
}
func (UnimplementedQueryServer) GaugeByID(context.Context, *GaugeByIDRequest) (*GaugeByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GaugeByID not implemented")
}
func (UnimplementedQueryServer) Gauges(context.Context, *GaugesRequest) (*GaugesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Gauges not implemented")
}
func (UnimplementedQueryServer) ActiveGauges(context.Context, *ActiveGaugesRequest) (*ActiveGaugesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActiveGauges not implemented")
}
func (UnimplementedQueryServer) ActiveGaugesPerDenom(context.Context, *ActiveGaugesPerDenomRequest) (*ActiveGaugesPerDenomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActiveGaugesPerDenom not implemented")
}
func (UnimplementedQueryServer) UpcomingGauges(context.Context, *UpcomingGaugesRequest) (*UpcomingGaugesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpcomingGauges not implemented")
}
func (UnimplementedQueryServer) UpcomingGaugesPerDenom(context.Context, *UpcomingGaugesPerDenomRequest) (*UpcomingGaugesPerDenomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpcomingGaugesPerDenom not implemented")
}
func (UnimplementedQueryServer) RewardsEst(context.Context, *RewardsEstRequest) (*RewardsEstResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RewardsEst not implemented")
}
func (UnimplementedQueryServer) LockableDurations(context.Context, *QueryLockableDurationsRequest) (*QueryLockableDurationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockableDurations not implemented")
}
func (UnimplementedQueryServer) mustEmbedUnimplementedQueryServer() {}

// UnsafeQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueryServer will
// result in compilation errors.
type UnsafeQueryServer interface {
	mustEmbedUnimplementedQueryServer()
}

func RegisterQueryServer(s grpc.ServiceRegistrar, srv QueryServer) {
	s.RegisterService(&Query_ServiceDesc, srv)
}

func _Query_ModuleToDistributeCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleToDistributeCoinsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ModuleToDistributeCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.incentives.Query/ModuleToDistributeCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ModuleToDistributeCoins(ctx, req.(*ModuleToDistributeCoinsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GaugeByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GaugeByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GaugeByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.incentives.Query/GaugeByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GaugeByID(ctx, req.(*GaugeByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Gauges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GaugesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Gauges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.incentives.Query/Gauges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Gauges(ctx, req.(*GaugesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ActiveGauges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActiveGaugesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ActiveGauges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.incentives.Query/ActiveGauges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ActiveGauges(ctx, req.(*ActiveGaugesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ActiveGaugesPerDenom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActiveGaugesPerDenomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ActiveGaugesPerDenom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.incentives.Query/ActiveGaugesPerDenom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ActiveGaugesPerDenom(ctx, req.(*ActiveGaugesPerDenomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_UpcomingGauges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpcomingGaugesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).UpcomingGauges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.incentives.Query/UpcomingGauges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).UpcomingGauges(ctx, req.(*UpcomingGaugesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_UpcomingGaugesPerDenom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpcomingGaugesPerDenomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).UpcomingGaugesPerDenom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.incentives.Query/UpcomingGaugesPerDenom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).UpcomingGaugesPerDenom(ctx, req.(*UpcomingGaugesPerDenomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_RewardsEst_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RewardsEstRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).RewardsEst(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.incentives.Query/RewardsEst",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).RewardsEst(ctx, req.(*RewardsEstRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_LockableDurations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryLockableDurationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).LockableDurations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.incentives.Query/LockableDurations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).LockableDurations(ctx, req.(*QueryLockableDurationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Query_ServiceDesc is the grpc.ServiceDesc for Query service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Query_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "osmosis.incentives.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ModuleToDistributeCoins",
			Handler:    _Query_ModuleToDistributeCoins_Handler,
		},
		{
			MethodName: "GaugeByID",
			Handler:    _Query_GaugeByID_Handler,
		},
		{
			MethodName: "Gauges",
			Handler:    _Query_Gauges_Handler,
		},
		{
			MethodName: "ActiveGauges",
			Handler:    _Query_ActiveGauges_Handler,
		},
		{
			MethodName: "ActiveGaugesPerDenom",
			Handler:    _Query_ActiveGaugesPerDenom_Handler,
		},
		{
			MethodName: "UpcomingGauges",
			Handler:    _Query_UpcomingGauges_Handler,
		},
		{
			MethodName: "UpcomingGaugesPerDenom",
			Handler:    _Query_UpcomingGaugesPerDenom_Handler,
		},
		{
			MethodName: "RewardsEst",
			Handler:    _Query_RewardsEst_Handler,
		},
		{
			MethodName: "LockableDurations",
			Handler:    _Query_LockableDurations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "osmosis/incentives/query.proto",
}
