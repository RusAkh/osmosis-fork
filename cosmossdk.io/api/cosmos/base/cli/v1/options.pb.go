// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: osmosis/autocli/v1/options.proto

package cliv1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ModuleOptions describes the CLI options for a Cosmos SDK module.
type ModuleOptions struct {
	// tx describes the tx command for the module.
	Tx *ServiceCommandDescriptor `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
	// query describes the query command for the module.
	Query *ServiceCommandDescriptor `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
}

func (m *ModuleOptions) Reset()         { *m = ModuleOptions{} }
func (m *ModuleOptions) String() string { return proto.CompactTextString(m) }
func (*ModuleOptions) ProtoMessage()    {}
func (*ModuleOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_99a27c3c2ecce4b5, []int{0}
}
func (m *ModuleOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModuleOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleOptions.Merge(m, src)
}
func (m *ModuleOptions) XXX_Size() int {
	return m.Size()
}
func (m *ModuleOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleOptions proto.InternalMessageInfo

func (m *ModuleOptions) GetTx() *ServiceCommandDescriptor {
	if m != nil {
		return m.Tx
	}
	return nil
}

func (m *ModuleOptions) GetQuery() *ServiceCommandDescriptor {
	if m != nil {
		return m.Query
	}
	return nil
}

// ServiceCommandDescriptor describes a CLI command based on a protobuf service.
type ServiceCommandDescriptor struct {
	// service is the fully qualified name of the protobuf service to build
	// the command from. It can be left empty if sub_commands are used instead
	// which may be the case if a module provides multiple tx and/or query
	// services.
	Service string `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
	// rpc_command_options are options for commands generated from rpc methods.
	// If no options are specified for a given rpc method on the service, a
	// command will be generated for that method with the default options.
	RpcCommandOptions []*RpcCommandOptions `protobuf:"bytes,2,rep,name=rpc_command_options,json=rpcCommandOptions,proto3" json:"rpc_command_options,omitempty"`
	// sub_commands is a map of optional sub-commands for this command based on
	// different protobuf services. The map key is used as the name of the
	// sub-command.
	SubCommands map[string]*ServiceCommandDescriptor `protobuf:"bytes,3,rep,name=sub_commands,json=subCommands,proto3" json:"sub_commands,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ServiceCommandDescriptor) Reset()         { *m = ServiceCommandDescriptor{} }
func (m *ServiceCommandDescriptor) String() string { return proto.CompactTextString(m) }
func (*ServiceCommandDescriptor) ProtoMessage()    {}
func (*ServiceCommandDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_99a27c3c2ecce4b5, []int{1}
}
func (m *ServiceCommandDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceCommandDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceCommandDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceCommandDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceCommandDescriptor.Merge(m, src)
}
func (m *ServiceCommandDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ServiceCommandDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceCommandDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceCommandDescriptor proto.InternalMessageInfo

func (m *ServiceCommandDescriptor) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *ServiceCommandDescriptor) GetRpcCommandOptions() []*RpcCommandOptions {
	if m != nil {
		return m.RpcCommandOptions
	}
	return nil
}

func (m *ServiceCommandDescriptor) GetSubCommands() map[string]*ServiceCommandDescriptor {
	if m != nil {
		return m.SubCommands
	}
	return nil
}

// RpcCommandOptions specifies options for commands generated from protobuf
// rpc methods.
type RpcCommandOptions struct {
	// rpc_method is short name of the protobuf rpc method that this command is
	// generated from.
	RpcMethod string `protobuf:"bytes,1,opt,name=rpc_method,json=rpcMethod,proto3" json:"rpc_method,omitempty"`
	// use is the one-line usage method. It also allows specifying an alternate
	// name for the command as the first word of the usage text.
	//
	// By default the name of an rpc command is the kebab-case short name of the
	// rpc method.
	Use string `protobuf:"bytes,2,opt,name=use,proto3" json:"use,omitempty"`
	// long is the long message shown in the 'help <this-command>' output.
	Long string `protobuf:"bytes,3,opt,name=long,proto3" json:"long,omitempty"`
	// short is the short description shown in the 'help' output.
	Short string `protobuf:"bytes,4,opt,name=short,proto3" json:"short,omitempty"`
	// example is examples of how to use the command.
	Example string `protobuf:"bytes,5,opt,name=example,proto3" json:"example,omitempty"`
	// alias is an array of aliases that can be used instead of the first word in
	// Use.
	Alias []string `protobuf:"bytes,6,rep,name=alias,proto3" json:"alias,omitempty"`
	// suggest_for is an array of command names for which this command will be
	// suggested - similar to aliases but only suggests.
	SuggestFor []string `protobuf:"bytes,7,rep,name=suggest_for,json=suggestFor,proto3" json:"suggest_for,omitempty"`
	// deprecated defines, if this command is deprecated and should print this
	// string when used.
	Deprecated string `protobuf:"bytes,8,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
	// version defines the version for this command. If this value is non-empty
	// and the command does not define a "version" flag, a "version" boolean flag
	// will be added to the command and, if specified, will print content of the
	// "Version" variable. A shorthand "v" flag will also be added if the command
	// does not define one.
	Version string `protobuf:"bytes,9,opt,name=version,proto3" json:"version,omitempty"`
	// flag_options are options for flags generated from rpc request fields.
	// By default all request fields are configured as flags. They can
	// also be configured as positional args instead using positional_args.
	FlagOptions map[string]*FlagOptions `protobuf:"bytes,10,rep,name=flag_options,json=flagOptions,proto3" json:"flag_options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// positional_args specifies positional arguments for the command.
	PositionalArgs []*PositionalArgDescriptor `protobuf:"bytes,11,rep,name=positional_args,json=positionalArgs,proto3" json:"positional_args,omitempty"`
	// skip specifies whether to skip this rpc method when generating commands.
	Skip bool `protobuf:"varint,12,opt,name=skip,proto3" json:"skip,omitempty"`
}

func (m *RpcCommandOptions) Reset()         { *m = RpcCommandOptions{} }
func (m *RpcCommandOptions) String() string { return proto.CompactTextString(m) }
func (*RpcCommandOptions) ProtoMessage()    {}
func (*RpcCommandOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_99a27c3c2ecce4b5, []int{2}
}
func (m *RpcCommandOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RpcCommandOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RpcCommandOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RpcCommandOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RpcCommandOptions.Merge(m, src)
}
func (m *RpcCommandOptions) XXX_Size() int {
	return m.Size()
}
func (m *RpcCommandOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RpcCommandOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RpcCommandOptions proto.InternalMessageInfo

func (m *RpcCommandOptions) GetRpcMethod() string {
	if m != nil {
		return m.RpcMethod
	}
	return ""
}

func (m *RpcCommandOptions) GetUse() string {
	if m != nil {
		return m.Use
	}
	return ""
}

func (m *RpcCommandOptions) GetLong() string {
	if m != nil {
		return m.Long
	}
	return ""
}

func (m *RpcCommandOptions) GetShort() string {
	if m != nil {
		return m.Short
	}
	return ""
}

func (m *RpcCommandOptions) GetExample() string {
	if m != nil {
		return m.Example
	}
	return ""
}

func (m *RpcCommandOptions) GetAlias() []string {
	if m != nil {
		return m.Alias
	}
	return nil
}

func (m *RpcCommandOptions) GetSuggestFor() []string {
	if m != nil {
		return m.SuggestFor
	}
	return nil
}

func (m *RpcCommandOptions) GetDeprecated() string {
	if m != nil {
		return m.Deprecated
	}
	return ""
}

func (m *RpcCommandOptions) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *RpcCommandOptions) GetFlagOptions() map[string]*FlagOptions {
	if m != nil {
		return m.FlagOptions
	}
	return nil
}

func (m *RpcCommandOptions) GetPositionalArgs() []*PositionalArgDescriptor {
	if m != nil {
		return m.PositionalArgs
	}
	return nil
}

func (m *RpcCommandOptions) GetSkip() bool {
	if m != nil {
		return m.Skip
	}
	return false
}

// FlagOptions are options for flags generated from rpc request fields.
// By default, all request fields are configured as flags based on the
// kebab-case name of the field. Fields can be turned into positional arguments
// instead by using RpcCommandOptions.positional_args.
type FlagOptions struct {
	// name is an alternate name to use for the field flag.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// shorthand is a one-letter abbreviated flag.
	Shorthand string `protobuf:"bytes,2,opt,name=shorthand,proto3" json:"shorthand,omitempty"`
	// usage is the help message.
	Usage string `protobuf:"bytes,3,opt,name=usage,proto3" json:"usage,omitempty"`
	// default_value is the default value as text.
	DefaultValue string `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	// default value is the default value as text if the flag is used without any
	// value.
	NoOptDefaultValue string `protobuf:"bytes,5,opt,name=no_opt_default_value,json=noOptDefaultValue,proto3" json:"no_opt_default_value,omitempty"`
	// deprecated is the usage text to show if this flag is deprecated.
	Deprecated string `protobuf:"bytes,6,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
	// shorthand_deprecated is the usage text to show if the shorthand of this
	// flag is deprecated.
	ShorthandDeprecated string `protobuf:"bytes,7,opt,name=shorthand_deprecated,json=shorthandDeprecated,proto3" json:"shorthand_deprecated,omitempty"`
	// hidden hides the flag from help/usage text
	Hidden bool `protobuf:"varint,8,opt,name=hidden,proto3" json:"hidden,omitempty"`
}

func (m *FlagOptions) Reset()         { *m = FlagOptions{} }
func (m *FlagOptions) String() string { return proto.CompactTextString(m) }
func (*FlagOptions) ProtoMessage()    {}
func (*FlagOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_99a27c3c2ecce4b5, []int{3}
}
func (m *FlagOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlagOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlagOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlagOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlagOptions.Merge(m, src)
}
func (m *FlagOptions) XXX_Size() int {
	return m.Size()
}
func (m *FlagOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_FlagOptions.DiscardUnknown(m)
}

var xxx_messageInfo_FlagOptions proto.InternalMessageInfo

func (m *FlagOptions) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FlagOptions) GetShorthand() string {
	if m != nil {
		return m.Shorthand
	}
	return ""
}

func (m *FlagOptions) GetUsage() string {
	if m != nil {
		return m.Usage
	}
	return ""
}

func (m *FlagOptions) GetDefaultValue() string {
	if m != nil {
		return m.DefaultValue
	}
	return ""
}

func (m *FlagOptions) GetNoOptDefaultValue() string {
	if m != nil {
		return m.NoOptDefaultValue
	}
	return ""
}

func (m *FlagOptions) GetDeprecated() string {
	if m != nil {
		return m.Deprecated
	}
	return ""
}

func (m *FlagOptions) GetShorthandDeprecated() string {
	if m != nil {
		return m.ShorthandDeprecated
	}
	return ""
}

func (m *FlagOptions) GetHidden() bool {
	if m != nil {
		return m.Hidden
	}
	return false
}

// PositionalArgDescriptor describes a positional argument.
type PositionalArgDescriptor struct {
	// proto_field specifies the proto field to use as the positional arg. Any
	// fields used as positional args will not have a flag generated.
	ProtoField string `protobuf:"bytes,1,opt,name=proto_field,json=protoField,proto3" json:"proto_field,omitempty"`
	// varargs makes a positional parameter a varargs parameter. This can only be
	// applied to last positional parameter and the proto_field must a repeated
	// field.
	Varargs bool `protobuf:"varint,2,opt,name=varargs,proto3" json:"varargs,omitempty"`
}

func (m *PositionalArgDescriptor) Reset()         { *m = PositionalArgDescriptor{} }
func (m *PositionalArgDescriptor) String() string { return proto.CompactTextString(m) }
func (*PositionalArgDescriptor) ProtoMessage()    {}
func (*PositionalArgDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_99a27c3c2ecce4b5, []int{4}
}
func (m *PositionalArgDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionalArgDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionalArgDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionalArgDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionalArgDescriptor.Merge(m, src)
}
func (m *PositionalArgDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *PositionalArgDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionalArgDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_PositionalArgDescriptor proto.InternalMessageInfo

func (m *PositionalArgDescriptor) GetProtoField() string {
	if m != nil {
		return m.ProtoField
	}
	return ""
}

func (m *PositionalArgDescriptor) GetVarargs() bool {
	if m != nil {
		return m.Varargs
	}
	return false
}

func init() {
	proto.RegisterType((*ModuleOptions)(nil), "osmosis.autocli.v1.ModuleOptions")
	proto.RegisterType((*ServiceCommandDescriptor)(nil), "osmosis.autocli.v1.ServiceCommandDescriptor")
	proto.RegisterMapType((map[string]*ServiceCommandDescriptor)(nil), "osmosis.autocli.v1.ServiceCommandDescriptor.SubCommandsEntry")
	proto.RegisterType((*RpcCommandOptions)(nil), "osmosis.autocli.v1.RpcCommandOptions")
	proto.RegisterMapType((map[string]*FlagOptions)(nil), "osmosis.autocli.v1.RpcCommandOptions.FlagOptionsEntry")
	proto.RegisterType((*FlagOptions)(nil), "osmosis.autocli.v1.FlagOptions")
	proto.RegisterType((*PositionalArgDescriptor)(nil), "osmosis.autocli.v1.PositionalArgDescriptor")
}

func init() { proto.RegisterFile("osmosis/autocli/v1/options.proto", fileDescriptor_99a27c3c2ecce4b5) }

var fileDescriptor_99a27c3c2ecce4b5 = []byte{
	// 694 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0xad, 0x9d, 0x36, 0x6d, 0x6e, 0xd2, 0xef, 0x6b, 0xa7, 0x15, 0x8c, 0x2a, 0x48, 0xa3, 0x20,
	0xa4, 0x22, 0x90, 0xad, 0x14, 0x81, 0x10, 0x3f, 0x0b, 0xda, 0xd2, 0x5d, 0x55, 0xe4, 0x16, 0x24,
	0xd8, 0x98, 0x89, 0x3d, 0x71, 0xac, 0x3a, 0x1e, 0x33, 0x63, 0x47, 0xed, 0x5b, 0xc0, 0x86, 0x2d,
	0xaf, 0xc3, 0xb2, 0x4b, 0x24, 0x36, 0xa8, 0x7d, 0x11, 0x34, 0x3f, 0x49, 0xdc, 0x36, 0x95, 0xa0,
	0xbb, 0x7b, 0xcf, 0x9c, 0xfb, 0x33, 0x73, 0x8e, 0x0d, 0x2d, 0x26, 0x06, 0x4c, 0xc4, 0xc2, 0x25,
	0x45, 0xce, 0x82, 0x24, 0x76, 0x87, 0x1d, 0x97, 0x65, 0x79, 0xcc, 0x52, 0xe1, 0x64, 0x9c, 0xe5,
	0x0c, 0x21, 0xc3, 0x70, 0x0c, 0xc3, 0x19, 0x76, 0xda, 0x5f, 0x2d, 0x58, 0xdc, 0x63, 0x61, 0x91,
	0xd0, 0x7d, 0xcd, 0x45, 0x2f, 0xc1, 0xce, 0x8f, 0xb1, 0xd5, 0xb2, 0x36, 0xea, 0x9b, 0x8f, 0x9c,
	0xab, 0x25, 0xce, 0x01, 0xe5, 0xc3, 0x38, 0xa0, 0xdb, 0x6c, 0x30, 0x20, 0x69, 0xb8, 0x43, 0x45,
	0xc0, 0xe3, 0x2c, 0x67, 0xdc, 0xb3, 0xf3, 0x63, 0xb4, 0x05, 0x73, 0x9f, 0x0b, 0xca, 0x4f, 0xb0,
	0x7d, 0x83, 0x06, 0xba, 0xb4, 0xfd, 0xcb, 0x06, 0x7c, 0x1d, 0x07, 0x61, 0x98, 0x17, 0xfa, 0x4c,
	0xed, 0x58, 0xf3, 0x46, 0x29, 0x7a, 0x07, 0x2b, 0x3c, 0x0b, 0xfc, 0x40, 0x97, 0xf8, 0xe6, 0xee,
	0xd8, 0x6e, 0x55, 0x36, 0xea, 0x9b, 0xf7, 0xa7, 0x2d, 0xe2, 0x65, 0x81, 0x19, 0x60, 0x2e, 0xef,
	0x2d, 0xf3, 0xcb, 0x10, 0xfa, 0x04, 0x0d, 0x51, 0x74, 0x47, 0x6d, 0x05, 0xae, 0xa8, 0x7e, 0xaf,
	0xfe, 0xe5, 0x62, 0xce, 0x41, 0xd1, 0x35, 0xa0, 0x78, 0x93, 0xe6, 0xfc, 0xc4, 0xab, 0x8b, 0x09,
	0xb2, 0x96, 0xc0, 0xd2, 0x65, 0x02, 0x5a, 0x82, 0xca, 0x11, 0x3d, 0x31, 0x57, 0x94, 0xa1, 0x7c,
	0xd9, 0x21, 0x49, 0x0a, 0x7a, 0xb3, 0x97, 0x55, 0xa5, 0xcf, 0xed, 0x67, 0x56, 0xfb, 0xfb, 0x2c,
	0x2c, 0x5f, 0xb9, 0x38, 0xba, 0x0b, 0x20, 0x1f, 0x6f, 0x40, 0xf3, 0x3e, 0x0b, 0xcd, 0xd8, 0x1a,
	0xcf, 0x82, 0x3d, 0x05, 0xc8, 0x75, 0x0a, 0xa1, 0x47, 0xd7, 0x3c, 0x19, 0x22, 0x04, 0xb3, 0x09,
	0x4b, 0x23, 0x5c, 0x51, 0x90, 0x8a, 0xd1, 0x2a, 0xcc, 0x89, 0x3e, 0xe3, 0x39, 0x9e, 0x55, 0xa0,
	0x4e, 0xa4, 0x62, 0xf4, 0x98, 0x0c, 0xb2, 0x84, 0xe2, 0x39, 0xad, 0x98, 0x49, 0x25, 0x9f, 0x24,
	0x31, 0x11, 0xb8, 0xda, 0xaa, 0x48, 0xbe, 0x4a, 0xd0, 0x3a, 0xd4, 0x45, 0x11, 0x45, 0x54, 0xe4,
	0x7e, 0x8f, 0x71, 0x3c, 0xaf, 0xce, 0xc0, 0x40, 0xbb, 0x8c, 0xa3, 0x26, 0x40, 0x48, 0x33, 0x4e,
	0x03, 0x92, 0xd3, 0x10, 0x2f, 0xa8, 0x9e, 0x25, 0x44, 0x0e, 0x1c, 0x52, 0x2e, 0x62, 0x96, 0xe2,
	0x9a, 0x1e, 0x68, 0x52, 0xf4, 0x01, 0x1a, 0xbd, 0x84, 0x44, 0x63, 0x6f, 0x80, 0xd2, 0xf2, 0xe9,
	0x5f, 0x79, 0xc3, 0xd9, 0x4d, 0x48, 0x64, 0x62, 0x23, 0x62, 0x6f, 0x82, 0xa0, 0x43, 0xf8, 0x3f,
	0x63, 0x22, 0x96, 0x09, 0x49, 0x7c, 0xc2, 0x23, 0x81, 0xeb, 0xaa, 0xfb, 0xc3, 0x69, 0xdd, 0xdf,
	0x8e, 0xa9, 0xaf, 0x79, 0x54, 0xd2, 0xe9, 0xbf, 0xac, 0x7c, 0x20, 0xe4, 0x2b, 0x8b, 0xa3, 0x38,
	0xc3, 0x8d, 0x96, 0xb5, 0xb1, 0xe0, 0xa9, 0x78, 0xcd, 0x87, 0xa5, 0xcb, 0xab, 0x4c, 0xb1, 0xcb,
	0x93, 0x8b, 0x76, 0x59, 0x9f, 0xb6, 0x45, 0xa9, 0x4d, 0xd9, 0x21, 0xdf, 0x6c, 0xa8, 0x97, 0x8e,
	0xe4, 0x12, 0x29, 0x19, 0x8c, 0xbe, 0x37, 0x15, 0xa3, 0x3b, 0x50, 0x53, 0xea, 0xf6, 0x49, 0x1a,
	0x1a, 0x5b, 0x4c, 0x00, 0x29, 0x6c, 0x21, 0x48, 0x44, 0x8d, 0x3b, 0x74, 0x82, 0xee, 0xc1, 0x62,
	0x48, 0x7b, 0xa4, 0x48, 0x72, 0x5f, 0xaf, 0xa6, 0x6d, 0xd2, 0x30, 0xe0, 0x7b, 0x89, 0x21, 0x17,
	0x56, 0x53, 0x26, 0x05, 0xf2, 0x2f, 0x72, 0xb5, 0x75, 0x96, 0x53, 0xb6, 0x9f, 0xe5, 0x3b, 0xe5,
	0x82, 0x8b, 0x6e, 0xa8, 0x5e, 0x71, 0x43, 0x07, 0x56, 0xc7, 0x8b, 0xf9, 0x25, 0xe6, 0xbc, 0x62,
	0xae, 0x8c, 0xcf, 0x76, 0x26, 0x25, 0xb7, 0xa0, 0xda, 0x8f, 0xc3, 0x90, 0xa6, 0xca, 0x5c, 0x0b,
	0x9e, 0xc9, 0xda, 0x87, 0x70, 0xfb, 0x1a, 0xe1, 0xa4, 0x69, 0xd5, 0x4f, 0xd6, 0xef, 0xc5, 0x34,
	0x19, 0x7d, 0x40, 0xa0, 0xa0, 0x5d, 0x89, 0x28, 0x53, 0x12, 0xae, 0x7c, 0x61, 0xab, 0xa6, 0xa3,
	0x74, 0x6b, 0xfb, 0xc7, 0x59, 0xd3, 0x3a, 0x3d, 0x6b, 0x5a, 0xbf, 0xcf, 0x9a, 0xd6, 0x97, 0xf3,
	0xe6, 0xcc, 0xe9, 0x79, 0x73, 0xe6, 0xe7, 0x79, 0x73, 0xe6, 0xe3, 0x83, 0x40, 0x89, 0x26, 0xc2,
	0x23, 0x27, 0x66, 0x2e, 0xc9, 0x62, 0x57, 0x03, 0x6e, 0x97, 0x08, 0xea, 0xea, 0x7f, 0xfc, 0x8b,
	0x20, 0x89, 0x87, 0x9d, 0x6e, 0x55, 0x8d, 0x7a, 0xfc, 0x27, 0x00, 0x00, 0xff, 0xff, 0xcd, 0xe5,
	0x4a, 0xe3, 0x06, 0x06, 0x00, 0x00,
}

func (m *ModuleOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModuleOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOptions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Tx != nil {
		{
			size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOptions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceCommandDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceCommandDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceCommandDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubCommands) > 0 {
		for k := range m.SubCommands {
			v := m.SubCommands[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOptions(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintOptions(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintOptions(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RpcCommandOptions) > 0 {
		for iNdEx := len(m.RpcCommandOptions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RpcCommandOptions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOptions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Service) > 0 {
		i -= len(m.Service)
		copy(dAtA[i:], m.Service)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Service)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RpcCommandOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcCommandOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RpcCommandOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Skip {
		i--
		if m.Skip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.PositionalArgs) > 0 {
		for iNdEx := len(m.PositionalArgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PositionalArgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOptions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.FlagOptions) > 0 {
		for k := range m.FlagOptions {
			v := m.FlagOptions[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOptions(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintOptions(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintOptions(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Deprecated) > 0 {
		i -= len(m.Deprecated)
		copy(dAtA[i:], m.Deprecated)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Deprecated)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SuggestFor) > 0 {
		for iNdEx := len(m.SuggestFor) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SuggestFor[iNdEx])
			copy(dAtA[i:], m.SuggestFor[iNdEx])
			i = encodeVarintOptions(dAtA, i, uint64(len(m.SuggestFor[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Alias) > 0 {
		for iNdEx := len(m.Alias) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Alias[iNdEx])
			copy(dAtA[i:], m.Alias[iNdEx])
			i = encodeVarintOptions(dAtA, i, uint64(len(m.Alias[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Example) > 0 {
		i -= len(m.Example)
		copy(dAtA[i:], m.Example)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Example)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Short) > 0 {
		i -= len(m.Short)
		copy(dAtA[i:], m.Short)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Short)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Long) > 0 {
		i -= len(m.Long)
		copy(dAtA[i:], m.Long)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Long)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Use) > 0 {
		i -= len(m.Use)
		copy(dAtA[i:], m.Use)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Use)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RpcMethod) > 0 {
		i -= len(m.RpcMethod)
		copy(dAtA[i:], m.RpcMethod)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.RpcMethod)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlagOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlagOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlagOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.ShorthandDeprecated) > 0 {
		i -= len(m.ShorthandDeprecated)
		copy(dAtA[i:], m.ShorthandDeprecated)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.ShorthandDeprecated)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Deprecated) > 0 {
		i -= len(m.Deprecated)
		copy(dAtA[i:], m.Deprecated)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Deprecated)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.NoOptDefaultValue) > 0 {
		i -= len(m.NoOptDefaultValue)
		copy(dAtA[i:], m.NoOptDefaultValue)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.NoOptDefaultValue)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DefaultValue) > 0 {
		i -= len(m.DefaultValue)
		copy(dAtA[i:], m.DefaultValue)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.DefaultValue)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Usage) > 0 {
		i -= len(m.Usage)
		copy(dAtA[i:], m.Usage)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Usage)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Shorthand) > 0 {
		i -= len(m.Shorthand)
		copy(dAtA[i:], m.Shorthand)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Shorthand)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionalArgDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionalArgDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionalArgDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Varargs {
		i--
		if m.Varargs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ProtoField) > 0 {
		i -= len(m.ProtoField)
		copy(dAtA[i:], m.ProtoField)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.ProtoField)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOptions(dAtA []byte, offset int, v uint64) int {
	offset -= sovOptions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ModuleOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovOptions(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovOptions(uint64(l))
	}
	return n
}

func (m *ServiceCommandDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if len(m.RpcCommandOptions) > 0 {
		for _, e := range m.RpcCommandOptions {
			l = e.Size()
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	if len(m.SubCommands) > 0 {
		for k, v := range m.SubCommands {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOptions(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovOptions(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovOptions(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RpcCommandOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RpcMethod)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Use)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Long)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Short)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Example)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if len(m.Alias) > 0 {
		for _, s := range m.Alias {
			l = len(s)
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	if len(m.SuggestFor) > 0 {
		for _, s := range m.SuggestFor {
			l = len(s)
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	l = len(m.Deprecated)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if len(m.FlagOptions) > 0 {
		for k, v := range m.FlagOptions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOptions(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovOptions(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovOptions(uint64(mapEntrySize))
		}
	}
	if len(m.PositionalArgs) > 0 {
		for _, e := range m.PositionalArgs {
			l = e.Size()
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	if m.Skip {
		n += 2
	}
	return n
}

func (m *FlagOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Shorthand)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Usage)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.NoOptDefaultValue)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Deprecated)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.ShorthandDeprecated)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if m.Hidden {
		n += 2
	}
	return n
}

func (m *PositionalArgDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProtoField)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if m.Varargs {
		n += 2
	}
	return n
}

func sovOptions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOptions(x uint64) (n int) {
	return sovOptions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ModuleOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tx == nil {
				m.Tx = &ServiceCommandDescriptor{}
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &ServiceCommandDescriptor{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceCommandDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceCommandDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceCommandDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcCommandOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpcCommandOptions = append(m.RpcCommandOptions, &RpcCommandOptions{})
			if err := m.RpcCommandOptions[len(m.RpcCommandOptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubCommands == nil {
				m.SubCommands = make(map[string]*ServiceCommandDescriptor)
			}
			var mapkey string
			var mapvalue *ServiceCommandDescriptor
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOptions
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOptions
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOptions
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthOptions
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOptions
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOptions
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOptions
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ServiceCommandDescriptor{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOptions(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOptions
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SubCommands[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpcCommandOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcCommandOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcCommandOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpcMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Use", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Use = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Long", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Long = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Short", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Short = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Example", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Example = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = append(m.Alias, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestFor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuggestFor = append(m.SuggestFor, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deprecated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlagOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlagOptions == nil {
				m.FlagOptions = make(map[string]*FlagOptions)
			}
			var mapkey string
			var mapvalue *FlagOptions
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOptions
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOptions
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOptions
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthOptions
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOptions
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOptions
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOptions
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FlagOptions{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOptions(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOptions
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FlagOptions[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionalArgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositionalArgs = append(m.PositionalArgs, &PositionalArgDescriptor{})
			if err := m.PositionalArgs[len(m.PositionalArgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Skip = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlagOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlagOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlagOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shorthand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shorthand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoOptDefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoOptDefaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deprecated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShorthandDeprecated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShorthandDeprecated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionalArgDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionalArgDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionalArgDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoField", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtoField = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Varargs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Varargs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOptions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOptions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOptions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOptions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOptions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOptions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOptions = fmt.Errorf("proto: unexpected end of group")
)
